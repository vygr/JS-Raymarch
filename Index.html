<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="robots" content="all" />
<title>Raymarching</title>
<style type="text/css">
</style>

<script type="text/javascript">

window.onload = main;

var gl;
var time = 0.0;
var start = 0.0;
var fps = 0;
var fpstime = 0.0;

var time_location;
var arg_aa_location;
var arg_ao_location;
var arg_depth_location;
var arg_ref_location;

function getShader(gl, id)
{
    var shaderScript = document.getElementById(id);
    if (!shaderScript) return null;

    var str = "";
    var k = shaderScript.firstChild;
    while (k)
    {
        if (k.nodeType == 3)
        str += k.textContent;
        k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type == "x-shader/x-fragment") shader = gl.createShader(gl.FRAGMENT_SHADER);
    else if (shaderScript.type == "x-shader/x-vertex") shader = gl.createShader(gl.VERTEX_SHADER);
    else return null;

    gl.shaderSource(shader, str);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

function main()
{
    var canvas = document.getElementById("canvas");
    gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (!gl)
    {
        alert("OpenGL could not be initialized.");
        document.getElementById('heading').innerHTML = "WebGL - Initialization Error";
        document.getElementById('info').innerHTML = "WebGL could not be initialized. Check that your browser supports WebGL.";
        return;
    }

    gl.getExtension('OES_standard_derivatives');

    var vertexShader = getShader(gl, "2d-vertex-shader");
    var fragmentShader = getShader(gl, "2d-fragment-shader");
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    {
        document.getElementById('heading').innerHTML = "WebGL - Shader Initialization Error";
        document.getElementById('info').innerHTML = "WebGL could not initialize one, or both, shaders.";
        gl.deleteProgram(program);
        return;
    }

    gl.useProgram(program);

    var positionLocation = gl.getAttribLocation(program, "a_position");
    var resolutionLocation = gl.getUniformLocation(program, "resolution");
    gl.uniform2f(resolutionLocation, canvas.width, canvas.height);

	arg_aa_location = gl.getUniformLocation(program, "arg_aa");
    gl.uniform1i(arg_aa_location, 0);
	arg_ao_location = gl.getUniformLocation(program, "arg_ao");
    gl.uniform1f(arg_ao_location, 0);
	arg_depth_location = gl.getUniformLocation(program, "arg_depth");
    gl.uniform1i(arg_depth_location, 0);
	arg_ref_location = gl.getUniformLocation(program, "arg_ref");
    gl.uniform1f(arg_ref_location, 0);

    var mx = Math.max(canvas.width, canvas.height);
    var xdivmx = canvas.width/mx;
    var ydivmx = canvas.height/mx;
    var screenRatioLocation = gl.getUniformLocation(program, "screenRatio");
    gl.uniform2f(screenRatioLocation, xdivmx, ydivmx);

    time_location = gl.getUniformLocation(program, "time");
    gl.uniform1f(time_location, time);

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1.0, -1.0,
     1.0, -1.0,
    -1.0,  1.0,
    -1.0,  1.0,
     1.0, -1.0,
     1.0,  1.0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    document.getElementById('info').innerHTML = "<i>Frame Rate</i>: ...";
    start = Date.now();
    render();
}

window.requestAnimFrame = (function()
{
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback, element)
        {
            return window.setTimeout(callback, 1000/60);
        };
})();

window.cancelRequestAnimFrame = (function()
{
    return window.cancelCancelRequestAnimationFrame ||
        window.webkitCancelRequestAnimationFrame ||
        window.mozCancelRequestAnimationFrame ||
        window.oCancelRequestAnimationFrame ||
        window.msCancelRequestAnimationFrame ||
        window.clearTimeout;
})();

function render()
{
	gl.uniform1i(arg_aa_location, document.getElementById("arg_aa").checked);
	gl.uniform1f(arg_ao_location, document.getElementById("arg_ao").value);
	gl.uniform1i(arg_depth_location, document.getElementById("arg_depth").value);
	gl.uniform1f(arg_ref_location, document.getElementById("arg_ref").value);

    var elapsedtime = (Date.now() - start)/1000.0;
    var framespeed = 1.0;
    time += framespeed*elapsedtime;
    gl.uniform1f(time_location, time);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    fps++;
    fpstime += elapsedtime;
    if(fpstime>=1.0)
	{
        fpstime -= 1.0;
        document.getElementById('info').innerHTML = "<i>Frame Rate</i>: " + fps + " fps";
        fps = 0;
    }
    start = Date.now();
    window.requestAnimationFrame(render, canvas);
}
</script>

<script id="2d-vertex-shader" type="x-shader/x-vertex">
attribute vec2 a_position;
varying vec2 surfacePosition;
uniform vec2 screenRatio;

void main()
{
    surfacePosition = a_position*screenRatio;
    gl_Position = vec4(a_position, 0, 1);
}
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
#ifdef GL_ES
    precision mediump float;
#endif

uniform float time;
uniform vec2 resolution;
uniform int arg_aa;
uniform int arg_depth;
uniform float arg_ao;
uniform float arg_ref;

#define PI 3.1415926535898

const float eps = 0.001;
const int maxIterations = 128;
const int maxIterationsShad = 24;
const float stepScale = 1.0;
const float stopThreshold = 0.001;
const float clipFar = 16.0;
const vec3 bgcolor = vec3(0.);

vec3 camPos = vec3(0., 0., time*0.1);
vec3 lightPos = vec3(camPos.x + 0.25*cos(time), camPos.y + 0.25*sin(time), camPos.z);

//field equation for a sphere.
float sphere(in vec3 p, in vec3 centerPos, float radius)
{
    return length(p-centerPos) - radius;
}

//field equation for a cube.
float box(vec3 p, vec3 b)
{
	vec3 d = abs(p) - b;
	return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

//field equation for a rounded cube.
float roundedCube(vec3 p, vec3 boxExtents, float edgeRadius)
{
	return length(max(abs(p)-boxExtents + vec3(edgeRadius), 0.0)) - edgeRadius;
}

//smooth min between two values
float smin(float a, float b, float k)
{
    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
    return mix(b, a, h) - k*h*(1.0-h);
}

//the scene
float scene(in vec3 p)
{
    p = mod(p, 1.0) - 0.5;
    return sphere(p, vec3(0.,0.,0.), 0.35);
//    return smin(box(p, vec3(0.25,0.25,0.25)),
//                sphere(p, vec3(0.,0.,0.), 0.35),
//                0.025);
//    return max(box(p, vec3(0.25,0.25,0.25)),
//                sphere(p, vec3(0.,0.,0.), 0.35));
//    return min(box(p, vec3(0.25,0.25,0.25)),
//                sphere(p, vec3(0.,0.,0.), 0.35));
//    return max(-box(p, vec3(0.25,0.25,0.25)),
//                sphere(p, vec3(0.,0.,0.), 0.35));
}

vec3 getNormal(in vec3 p)
{
	return normalize(vec3(
		scene(vec3(p.x+eps,p.y,p.z))-scene(vec3(p.x-eps,p.y,p.z)),
		scene(vec3(p.x,p.y+eps,p.z))-scene(vec3(p.x,p.y-eps,p.z)),
		scene(vec3(p.x,p.y,p.z+eps))-scene(vec3(p.x,p.y,p.z-eps))
	));
}

float rayMarching(vec3 origin, vec3 dir, float start, float end)
{
    float sceneDist = 1e4;
	float rayDepth = start;
	for (int i = 0; i < maxIterations; i++)
    {
		sceneDist = scene(origin + dir*rayDepth);
		if ((sceneDist < stopThreshold) || (rayDepth >= end)) break;
		rayDepth += sceneDist*stepScale;
	}
	if (sceneDist >= stopThreshold) rayDepth = end;
	else rayDepth += sceneDist;
	return rayDepth;
}

float calculateAO(vec3 p, vec3 n)
{
   const float AO_SAMPLES = 5.0;
   float r = 0.0;
   float w = 1.0;
   for (float i=1.0; i<=AO_SAMPLES; i++)
   {
      float d0 = i*0.2;
      r += w*(d0 - scene(p + n*d0));
      w *= 0.5;
   }
   return 1.0-clamp(r,0.0,1.0);
}

float softShadow(vec3 ro, vec3 rd, float start, float end, float k)
{
    float shade = 1.0;
    float dist = start;
    float stepDist = end/float(maxIterationsShad);
    for (int i=0; i<maxIterationsShad; i++)
    {
        float h = scene(ro + rd*dist);
        shade = min(shade, k*h/dist);
        dist += min(h, stepDist*2.);
        if (h<0.001 || dist > end) break;
    }
    return min(max(shade, 0.) + 0.25, 1.0);
}

vec3 lighting(vec3 sp, vec3 sn, vec3 cp)
{
	vec3 objColor = floor(mod(sp*0.5, 1.0)+0.5);
    objColor = clamp(objColor, 0.0, 1.0);

    vec3 lp = lightPos;
    vec3 ld = lp-sp;
    vec3 lcolor = vec3(1.,1.,1.);

    float len = length(ld);
    ld /= len;
    float lightAtten = min(1.0 / (0.25*len*len), 1.0);

    vec3 ref = reflect(-ld, sn);
	float ss=softShadow(sp, ld, stopThreshold*2.0, len, 32.0);

    float ao = 1.0-arg_ao;
	if (ao < 1.0) ao = ao + (1.0-ao)*calculateAO(sp, sn);

    float ambient = .05;
    float specularPower = 8.0;
    float diffuse = max(0.0, dot(sn, ld));
    float specular = max(0.0, dot(ref, normalize(cp-sp)));
    specular = pow(specular, specularPower);
    return (objColor*(diffuse*0.8+ambient)+specular*0.5)*lcolor*lightAtten*ss*ao;
}

vec3 scene_ray(vec3 ro, vec3 rd)
{
	float dist = rayMarching(ro, rd, 0.0, clipFar);
	if (dist >= clipFar) return bgcolor;
	vec3 sp = ro + rd*dist;
	vec3 sn = getNormal(sp);
	vec3 color = lighting(sp, sn, ro);
	float ref = arg_ref;
	for (int i = 1; i > 0; i++)
	{
		if (i > arg_depth) break;
		ro = sp;
		rd = reflect(rd, sn);
		dist = rayMarching(ro, rd, stopThreshold*5.0, clipFar);
		if (dist >= clipFar)
		{
			color += bgcolor*ref;
			break;
		}
		sp = ro + rd*dist;
		sn = getNormal(sp);
		color += lighting(sp, sn, ro)*ref;
		ref *= arg_ref;
	}
	return clamp(color, 0.0, 1.0);
}

void main(void)
{
	const float FOV = 0.5;
    vec2 aspect = vec2(resolution.x/resolution.y, 1.0);
	vec3 lookAt = vec3(0., 0., 0.);
    vec3 forward = normalize(lookAt-camPos);
    vec3 right = normalize(vec3(forward.z, 0., -forward.x));
    vec3 up = normalize(cross(forward,right));

	vec2 screenCoords = (2.0*gl_FragCoord.xy/resolution.xy - 1.0)*aspect;
    vec3 rd = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);
	vec3 color = scene_ray(camPos, rd);
	float scale = 1.0;
	if (arg_aa != 0)
	{
		scale = 0.25;

		screenCoords = (2.0*(gl_FragCoord.xy+vec2(0.5, 0.0))/resolution.xy - 1.0)*aspect;
	    rd = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);
		color += scene_ray(camPos, rd);

		screenCoords = (2.0*(gl_FragCoord.xy+vec2(0.0, 0.5))/resolution.xy - 1.0)*aspect;
	    rd = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);
		color += scene_ray(camPos, rd);

		screenCoords = (2.0*(gl_FragCoord.xy+vec2(0.5, 0.5))/resolution.xy - 1.0)*aspect;
	    rd = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);
		color += scene_ray(camPos, rd);
	}
	gl_FragColor = vec4(color*scale, 1.0);
}
</script>
</head>
<body>
	<div style="width:100%;">
		<div style="float:left; width:80%;">
			<h1 id="heading">Raymarching Test</h1>
	        <canvas id="canvas" width="1024" height="768"></canvas>
	        <div id="info"></div>
		</div>
		<div style="float:left; width:20%;">
			<input id="arg_aa" type="checkbox">Anti Alias<br>
			<input id="arg_ao" type="range" min="0" max="1" step="0.001" value ="0"/>Ambient Oclusion<br>
			<input id="arg_depth" type="range" min="0" max="2" step="1" value ="0"/>Reflection Depth<br>
			<input id="arg_ref" type="range" min="0" max="1" step="0.001" value ="0.3"/>Reflection Coef<br>
		</div>
	</div>
</body>
</html>
